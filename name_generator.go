package babynamer

import (
	"golang.org/x/net/context"

	"github.com/AndyNortrup/baby-namer/names"
	"github.com/AndyNortrup/baby-namer/usage"
	"google.golang.org/appengine/datastore"
	"google.golang.org/appengine/log"
)

type NameGenerator struct {
	user string
	ctx  context.Context
}

func NewNameGenerator(ctx context.Context, username string) *NameGenerator {
	gen := &NameGenerator{ctx: ctx}
	gen.user = username

	return gen
}

func (gen *NameGenerator) getName(previous string) (*names.Name, error) {
	//Get a name that has been recommended

	//Get a random name if nothing else
	return gen.getRandomName(names.FemaleFilter)
}

//getRecommendedName gets a list of names from the datastore that were
// recommended by a different user, and have not been rejected by any user
func (gen *NameGenerator) getRecommendedName(previous string) (*NameDetails, error) {
	query := datastore.NewQuery(EntityTypeNameDetails).
		Filter("RecommendedBy >", "").
		Filter("ApprovedBy =", "").
		Filter("RejectedBy =", "")

	for t := query.Run(gen.ctx); ; {
		details := &NameDetails{}
		_, err := t.Next(details)
		if err == datastore.Done {
			log.Infof(gen.ctx, "No recommended names found.")
			return nil, nil
		} else if err != nil {
			log.Infof(gen.ctx, "Error retriving recommended names: %v", err)
			return nil, err
		} else if details.RecommendedBy != gen.user && previous != details.Name {
			log.Infof(gen.ctx, "Returning recommended name: %v", details)
			return details, nil
		}
	}
}

//getRandomName makes repeated calls to the random name service until it finds
// one that the current user has not previously make a decision on.
func (gen *NameGenerator) getRandomName(gender names.Gender) (*names.Name, error) {
	return names.GetRandomName(gen.ctx, gender)
}

// getUndecidedName finds a name in the datastore that has not been recommended or rejected.
// Returns nil, nil if there are no names that meet this criteria.
func (gen *NameGenerator) getUndecidedName(usage *usage.Usage) (*NameDetails, error) {

	log.Infof(gen.ctx, "Usage Provided: %v", usage)

	query := datastore.NewQuery(EntityTypeNameDetails).
		Filter("RecommendedBy = ", "").
		Filter("ApprovedBy =", "").
		Filter("RejectedBy =", "").
		Filter("Usages.UsageFull =", usage.UsageFull)

	for t := query.Run(gen.ctx); ; {
		detail := &NameDetails{}
		_, err := t.Next(detail)
		if err == datastore.Done {
			log.Infof(gen.ctx, "No undecided names returned.")
			return nil, nil
		} else if err != nil {
			return nil, err
		} else {
			return detail, nil
		}
	}
}

func (gen *NameGenerator) getUsage() *usage.Usage {
	rndUsage := usage.NewUsageGenerator(gen.ctx).RandomUsageCode()
	return &usage.Usage{UsageFull: usage.GetNameOrigins()[rndUsage].Plain}
}

//isRejected returns a boolean value to tell you if a name generated by the
// random name service has been previously rejected
func (gen *NameGenerator) isRejected(details *NameDetails) bool {

	//Get all of the instnace of the name that have been rejected by someone.
	query := datastore.NewQuery(EntityTypeNameDetails).
		Filter("Name =", details.Name).
		Filter("RejectedBy >", "")

	t := query.Run(gen.ctx)

	for {
		result := &NameDetails{}
		_, err := t.Next(result)
		if err == datastore.Done {
			//If we get no result than the name has not been rejected.
			return false
		}
		if err != nil {
			//If we get an error, we'll just say no it hasn't been rejected
			log.Warningf(gen.ctx,
				"Unable to validate if name has already been rejected: %v", err)
			return false
		}
		//If there are any results at all, than the name has been rejected
		log.Infof(gen.ctx, "The name '%v' has not been previously rejected.",
			details.Name)
		return true
	}
}
