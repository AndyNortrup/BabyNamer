package main

import (
	"golang.org/x/net/context"

	"google.golang.org/appengine/datastore"
	"google.golang.org/appengine/log"
	"google.golang.org/appengine/user"
)

type NameGenerator struct {
	user string
	ctx  context.Context
}

func NewNameGenerator(ctx context.Context) *NameGenerator {
	gen := &NameGenerator{ctx: ctx}
	gen.user = user.Current(ctx).String()

	return gen
}

func (gen *NameGenerator) getName(previous string) (*NameDetails, error) {
	name, err := gen.getRecommendedName(previous)
	if err != nil {
		return &NameDetails{}, err
	}

	if name != nil && name.Name != "" {
		log.Infof(gen.ctx, "Returning recommended name: %v", name.Name)
		return name, nil
	}

	log.Infof(gen.ctx, "Returning random name")
	return gen.getRandomName()
}

//getRecommendedName gets a list of names from the datastore that were
// recommended by a different user, and have not been rejected by any user
func (gen *NameGenerator) getRecommendedName(previous string) (*NameDetails, error) {
	query := datastore.NewQuery(EntityTypeNameDetails).
		Filter("RecommendedBy >", "").
		Filter("ApprovedBy =", "").
		Filter("RejectedBy =", "")

	url, urlErr := user.LogoutURL(gen.ctx, "/")
	if urlErr != nil {
		log.Errorf(gen.ctx, "Error building logout URL: %v", url)
	}

	for t := query.Run(gen.ctx); ; {
		details := &NameDetails{}
		_, err := t.Next(details)
		if err == datastore.Done {
			log.Infof(gen.ctx, "No recommended names found.")
			return nil, nil
		} else if err != nil {
			log.Infof(gen.ctx, "Error retriving recommended names: %v", err)
			return nil, err
		} else if details.RecommendedBy != gen.user && previous != details.Name {
			log.Infof(gen.ctx, "Returning recommended name: %v", details)
			return details, nil
		}
	}
}

//getRandomName makes repeated calls to the random name service until it finds
// one that the current user has not previously make a decision on.
func (gen *NameGenerator) getRandomName() (*NameDetails, error) {
	reject := true

	service := NewRandomNameService(gen.ctx)

	for reject {

		randomName, err := service.getNameFromService()
		if err != nil || randomName.Name == "" {
			log.Warningf(gen.ctx, "Error retriving random name: %v", err)
		}

		//Check the datastore for an existing copy of this name.
		datastoreNameMgr := &DatastoreNameManager{
			username: gen.user,
			name:     randomName.Name,
			ctx:      gen.ctx,
		}

		currentListing, _, err := datastoreNameMgr.getNameFromDatastore()

		if err == nil {
			//Check if we have already made a decision
			isDuplicateDecision := checkDuplicateDecision(currentListing, gen.user)
			if isDuplicateDecision == nil {
				reject = false
			}
		}

	}
	return nil, nil

}

//isRejected returns a boolean value to tell you if a name generated by the
// random name service has been previously rejected
func (gen *NameGenerator) isRejected(details *NameDetails) bool {

	//Get all of the instnace of the name that have been rejected by someone.
	query := datastore.NewQuery(EntityTypeNameDetails).
		Filter("Name =", details.Name).
		Filter("RejectedBy >", "")

	t := query.Run(gen.ctx)

	for {
		result := &NameDetails{}
		_, err := t.Next(result)
		if err == datastore.Done {
			//If we get no result than the name has not been rejected.
			return false
		}
		if err != nil {
			//If we get an error, we'll just say no it hasn't been rejected
			log.Warningf(gen.ctx,
				"Unable to validate if name has already been rejected: %v", err)
			return false
		}
		//If there are any results at all, than the name has been rejected
		log.Infof(gen.ctx, "The name '%v' has not been previously rejected.",
			details.Name)
		return true
	}
}
