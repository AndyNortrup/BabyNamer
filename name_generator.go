package babynamer

import (
	"golang.org/x/net/context"

	"github.com/AndyNortrup/baby-namer/usage"
	"google.golang.org/appengine/datastore"
	"google.golang.org/appengine/log"
)

type NameGenerator struct {
	user string
	ctx  context.Context
}

func NewNameGenerator(ctx context.Context, username string) *NameGenerator {
	gen := &NameGenerator{ctx: ctx}
	gen.user = username

	return gen
}

func (gen *NameGenerator) getName(previous string) (*NameDetails, error) {
	name, err := gen.getRecommendedName(previous)
	if err != nil {
		return &NameDetails{}, err
	}

	if name != nil && name.Name != "" {
		log.Infof(gen.ctx, "Returning recommended name: %v", name.Name)
		return name, nil
	}

	rndUsage := usage.NewUsageGenerator(gen.ctx, gen.user).RandomUsageCode()
	usage := &usage.Usage{UsageFull: usage.GetNameOrigins()[rndUsage].Plain}
	name, err = gen.getUndecidedName(usage)

	if name != nil && err == nil {
		log.Infof(gen.ctx, "Returning undecided name: %v", name.Name)
		return name, nil
	}

	log.Infof(gen.ctx, "Returning random name")
	return gen.getRandomName()
}

//getRecommendedName gets a list of names from the datastore that were
// recommended by a different user, and have not been rejected by any user
func (gen *NameGenerator) getRecommendedName(previous string) (*NameDetails, error) {
	query := datastore.NewQuery(EntityTypeNameDetails).
		Filter("RecommendedBy >", "").
		Filter("ApprovedBy =", "").
		Filter("RejectedBy =", "")

	for t := query.Run(gen.ctx); ; {
		details := &NameDetails{}
		_, err := t.Next(details)
		if err == datastore.Done {
			log.Infof(gen.ctx, "No recommended names found.")
			return nil, nil
		} else if err != nil {
			log.Infof(gen.ctx, "Error retriving recommended names: %v", err)
			return nil, err
		} else if details.RecommendedBy != gen.user && previous != details.Name {
			log.Infof(gen.ctx, "Returning recommended name: %v", details)
			return details, nil
		}
	}
}

//getRandomName makes repeated calls to the random name service until it finds
// one that the current user has not previously make a decision on.
func (gen *NameGenerator) getRandomName() (*NameDetails, error) {
	reject := true

	service := NewRandomNameService(gen.ctx)
	usageGen := usage.NewUsageGenerator(gen.ctx, gen.user)

	for reject {

		rndUsage := usageGen.RandomUsageCode()

		randomName, err := service.getNameFromService(rndUsage)
		if err != nil || randomName.Name == "" {
			log.Warningf(gen.ctx, "Error retriving random name: %v\nRandom Name: %#v", err, randomName)
		}

		//Check the datastore for an existing copy of this name.
		mgr := NewDatastoreNameManager(gen.ctx, gen.user)

		currentListing, _, err := mgr.getNameFromDatastore(randomName.Name)

		if err != nil {
			log.Errorf(gen.ctx, "Name not found in current datastore: %v", err)
			return randomName, nil
		} else {
			//Check if we have already made a decision
			isDuplicateDecision := checkDuplicateDecision(currentListing, gen.user)
			if isDuplicateDecision == nil {
				log.Infof(gen.ctx, "The name %v has not been decided by %v", currentListing.Name, gen.user)
				reject = false
			} else {
				log.Debugf(gen.ctx, "The name %v has been decided by %v", currentListing.Name, gen.user)
			}
		}

	}
	return nil, nil

}

// getUndecidedName finds a name in the datastore that has not been recommended or rejected.
// Returns nil, nil if there are no names that meet this criteria.
func (gen *NameGenerator) getUndecidedName(usage *usage.Usage) (*NameDetails, error) {

	query := datastore.NewQuery(EntityTypeNameDetails).
		Filter("RecommendedBy = ", "").
		Filter("ApprovedBy =", "").
		Filter("RejectedBy =", "").
		Filter("Usages.UsageFull =", usage.UsageFull)

	for t := query.Run(gen.ctx); ; {
		detail := &NameDetails{}
		_, err := t.Next(detail)
		if err == datastore.Done {
			log.Infof(gen.ctx, "No names returned.")
			return nil, nil
		} else if err != nil {
			return nil, err
		} else {
			return detail, nil
		}
	}
}

//isRejected returns a boolean value to tell you if a name generated by the
// random name service has been previously rejected
func (gen *NameGenerator) isRejected(details *NameDetails) bool {

	//Get all of the instnace of the name that have been rejected by someone.
	query := datastore.NewQuery(EntityTypeNameDetails).
		Filter("Name =", details.Name).
		Filter("RejectedBy >", "")

	t := query.Run(gen.ctx)

	for {
		result := &NameDetails{}
		_, err := t.Next(result)
		if err == datastore.Done {
			//If we get no result than the name has not been rejected.
			return false
		}
		if err != nil {
			//If we get an error, we'll just say no it hasn't been rejected
			log.Warningf(gen.ctx,
				"Unable to validate if name has already been rejected: %v", err)
			return false
		}
		//If there are any results at all, than the name has been rejected
		log.Infof(gen.ctx, "The name '%v' has not been previously rejected.",
			details.Name)
		return true
	}
}
